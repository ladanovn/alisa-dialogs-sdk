"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const http_1 = __importDefault(require("http"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const commands_1 = __importDefault(require("./commands"));
const sessions_1 = require("./sessions");
const context_1 = __importDefault(require("./context"));
const imagesApi_1 = __importDefault(require("./imagesApi"));
const utils_1 = require("./utils");
const middlewares_1 = require("./middlewares");
const stateMiddleware_1 = __importDefault(require("./middlewares/stateMiddleware"));
const eventEmitter_1 = __importDefault(require("./eventEmitter"));
const constants_1 = require("./constants");
const DEFAULT_SESSIONS_LIMIT = 1000;
const DEFAULT_RESPONSE_TIMEOUT = 1200;
class Alice {
    constructor(config = {}) {
        this.anyCallback = null;
        this.welcomeCallback = null;
        this.commands = new commands_1.default(config.fuseOptions || null);
        this.middlewares = [stateMiddleware_1.default()];
        this.scenes = [];
        this.currentScene = null;
        this.sessions = new sessions_1.Sessions();
        this.config = config;
        this.imagesApi = new imagesApi_1.default({
            oAuthToken: this.config.oAuthToken,
            skillId: this.config.skillId,
        });
        this.timeoutCallback = async (ctx) => ctx.reply(constants_1.DEFAULT_TIMEOUT_CALLBACK_MESSAGE);
    }
    /* @TODO: Implement watchers (errors, messages) */
    // tslint:disable-next-line:no-empty
    on(event, callback) {
        eventEmitter_1.default.subscribe(event, callback);
    }
    /**
     * Attach alice middleware to the application
     * @param {Function} middleware - function, that receives {context}
     * and makes some modifications with it.
     */
    use(middleware) {
        if (!utils_1.isFunction(middleware)) {
            throw new Error('Any middleware could only be a function.');
        }
        this.middlewares.push(middleware);
    }
    // Handler for every new session
    welcome(callback) {
        this.welcomeCallback = callback;
    }
    command(name, callback) {
        this.commands.add(name, callback);
    }
    // If no matches, this fn will be invoked
    any(callback) {
        this.anyCallback = callback;
    }
    /**
     * Match the request with action handler,
     * compose and return a reply.
     * @param {Object} req — JSON request from the client
     * @param {Function} sendResponse — Express res function while listening on port.
     */
    async handleRequestBody(req, sendResponse) {
        /* clear old sessions */
        if (this.sessions.length > (this.config.sessionsLimit || DEFAULT_SESSIONS_LIMIT)) {
            this.sessions.flush();
        }
        /* initializing session */
        const sessionId = utils_1.selectSessionId(req);
        const session = this.sessions.findOrCreate(sessionId);
        /**
         * Initializing context of the request
         */
        const ctxDefaultParams = {
            req,
            session,
            sendResponse: sendResponse || null,
            /**
             * if Alice is listening on express.js port, add this server instance
             * to the context
             */
            server: this.server || null,
            scenes: this.scenes,
            middlewares: this.middlewares,
            eventEmitter: eventEmitter_1.default,
        };
        const ctxInstance = new context_1.default(ctxDefaultParams);
        const context = await middlewares_1.applyMiddlewares(this.middlewares, ctxInstance);
        eventEmitter_1.default.dispatch(constants_1.EVENT_MESSAGE_RECIEVED, {
            data: context.message,
            session: context.session,
        });
        /* check whether current scene is not defined */
        if (!session.getData('currentScene')) {
            session.setData('currentScene', null);
        }
        /* give control to the current scene */
        if (session.getData('currentScene') !== null) {
            const matchedScene = this.scenes.find(scene => {
                return scene.name === session.getData('currentScene');
            });
            /**
             * Checking whether that's the leave scene
             * activation trigger
             */
            if (matchedScene) {
                if (await matchedScene.isLeaveCommand(context)) {
                    const sceneResponse = await matchedScene.handleSceneRequest(req, sendResponse, context, 'leave');
                    session.setData('currentScene', null);
                    return sceneResponse;
                }
                else {
                    const sceneResponse = await matchedScene.handleSceneRequest(req, sendResponse, context);
                    if (sceneResponse) {
                        return sceneResponse;
                    }
                }
            }
        }
        else {
            // Looking for scene's activational phrases
            let matchedScene = null;
            for (const scene of this.scenes) {
                const result = await scene.isEnterCommand(context);
                if (result) {
                    matchedScene = scene;
                }
            }
            if (matchedScene) {
                session.setData('currentScene', matchedScene.name);
                const sceneResponse = await matchedScene.handleSceneRequest(req, sendResponse, context, 'enter');
                if (sceneResponse) {
                    return sceneResponse;
                }
            }
        }
        const requestedCommands = await this.commands.search(context);
        if (req.session.new && this.welcomeCallback) {
            if (this.welcomeCallback) {
                return await this.welcomeCallback(context);
            }
        }
        // It's a match with registered command
        if (requestedCommands.length !== 0) {
            const requestedCommand = requestedCommands[0];
            context.command = requestedCommand;
            return await requestedCommand.callback(context);
        }
        // No matches with commands
        if (!this.anyCallback) {
            throw new Error([
                `alice.any(ctx => ctx.reply('404')) Method must be defined`,
                'to catch anything that not matches with commands',
            ].join('\n'));
        }
        return await this.anyCallback(context);
    }
    // same as handleRequestBody, syntax sugar
    async handleRequest(req, sendResponse) {
        return await Promise.race([
            /* proxy request to dev server, if enabled */
            this.config.devServerUrl
                ? await this.handleProxyRequest(req, this.config.devServerUrl, sendResponse)
                : await this.handleRequestBody(req, sendResponse),
            utils_1.rejectsIn(this.config.responseTimeout || DEFAULT_RESPONSE_TIMEOUT),
        ])
            .then(result => result)
            .catch(async (error) => {
            eventEmitter_1.default.dispatch(constants_1.EVENT_MESSAGE_NOT_SENT);
            this.timeoutCallback(new context_1.default({ req, sendResponse }));
        });
    }
    async listen(webhookPath = '/', port = 80, callback) {
        return new Promise(resolve => {
            this.server = http_1.default
                .createServer(async (request, response) => {
                const body = [];
                request
                    .on('data', chunk => {
                    body.push(chunk);
                })
                    .on('end', async () => {
                    const requestData = Buffer.concat(body).toString();
                    if (request.method === 'POST' && request.url === webhookPath) {
                        const handleResponseCallback = (responseBody) => {
                            response.statusCode = 200;
                            response.setHeader('Content-Type', 'application/json');
                            response.end(JSON.stringify(responseBody));
                        };
                        try {
                            const requestBody = JSON.parse(requestData);
                            return await this.handleRequest(requestBody, handleResponseCallback);
                        }
                        catch (error) {
                            throw new Error(error);
                        }
                    }
                    else {
                        response.statusCode = 400;
                        response.end();
                    }
                });
            })
                .listen(port, () => {
                eventEmitter_1.default.dispatch(constants_1.EVENT_SERVER_STARTED);
                if (utils_1.isFunction(callback)) {
                    return callback();
                }
                return resolve();
            });
        });
    }
    registerScene(scene) {
        // Allow for multiple scenes to be registered at once.
        if (Array.isArray(scene)) {
            scene.forEach(sceneItem => this.scenes.push(sceneItem));
        }
        else {
            this.scenes.push(scene);
        }
    }
    async uploadImage(imageUrl) {
        return await this.imagesApi.uploadImage(imageUrl);
    }
    async getImages() {
        return await this.imagesApi.getImages();
    }
    stopListening() {
        if (this.server && this.server.close) {
            this.server.close();
            eventEmitter_1.default.dispatch(constants_1.EVENT_SERVER_STOPPED);
        }
    }
    async handleProxyRequest(request, devServerUrl, sendResponse) {
        try {
            const res = await node_fetch_1.default(devServerUrl, {
                method: 'POST',
                headers: { 'Content-type': 'application/json' },
                body: JSON.stringify(request),
            });
            const json = await res.json();
            eventEmitter_1.default.dispatch(constants_1.EVENT_MESSAGE_PROXIED, { data: request });
            return sendResponse(json);
        }
        catch (error) {
            eventEmitter_1.default.dispatch(constants_1.EVENT_MESSAGE_PROXY_ERROR, { data: request });
        }
    }
}
exports.default = Alice;
