"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = __importDefault(require("./command"));
exports.Command = command_1.default;
const utils_1 = __importDefault(require("./utils"));
const fuse_js_1 = __importDefault(require("fuse.js"));
const constants_1 = require("./constants");
class Commands {
    constructor(config = null) {
        this.commands = [];
        this.fuseOptions = config || {
            tokenize: true,
            threshold: 0.1,
            distance: 10,
            keys: ['name'],
        };
    }
    get() {
        return this.commands;
    }
    get _matchers() {
        return this.commands.filter(command => command.type === constants_1.TYPE_MATCHER);
    }
    get _strings() {
        return this.commands.filter(command => [constants_1.TYPE_STRING, constants_1.TYPE_ARRAY].includes(command.type));
    }
    get _figures() {
        return this.commands.filter(command => command.type === constants_1.TYPE_FIGURE);
    }
    get _regexps() {
        return this.commands.filter(command => command.type === constants_1.TYPE_REGEXP);
    }
    async search(ctx) {
        const matchedStrings = this._searchStrings(ctx.message);
        const matchedRegexps = this._searchRegexps(ctx.message);
        const matchedFigures = this._searchFigures(ctx.message);
        const matchedMatchers = await this._searchMatchers(ctx);
        if (matchedMatchers.length > 0) {
            return matchedMatchers;
        }
        else if (matchedStrings.length > 0) {
            return matchedStrings;
        }
        else if (matchedRegexps.length > 0) {
            return matchedRegexps;
        }
        else if (matchedFigures.length > 0) {
            return matchedFigures;
        }
        else {
            return [];
        }
    }
    get length() {
        return this.commands.length;
    }
    add(name, callback) {
        this.commands.push(new command_1.default(name, callback));
    }
    flush() {
        this.commands = [];
    }
    async _searchMatchers(ctx) {
        const matchers = this._matchers;
        for (const matcher of matchers) {
            const matchPredicate = matcher.name;
            if (await matchPredicate(ctx)) {
                return [matcher];
            }
        }
        return [];
    }
    _searchStrings(requestedCommandName) {
        const stringCommands = this._strings;
        const fuse = new fuse_js_1.default(stringCommands, this.fuseOptions);
        return fuse.search(requestedCommandName);
    }
    _searchFigures(requestedCommandName) {
        const figuresCommands = this._figures;
        return figuresCommands.filter(figure => {
            const reg = utils_1.default.getFiguresRegexp(figure.name);
            return requestedCommandName.match(reg);
        });
    }
    _searchRegexps(requestedCommandName) {
        const regexpCommands = this._regexps;
        // @TODO: include matches and captured groups
        return regexpCommands.filter(reg => requestedCommandName.match(reg.name));
    }
}
exports.default = Commands;
