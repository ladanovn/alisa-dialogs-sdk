"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const replyBuilder_1 = __importDefault(require("./replyBuilder"));
const buttonBuilder_1 = __importDefault(require("./buttonBuilder"));
const card_1 = require("./card");
const reply_1 = __importDefault(require("./reply"));
const eventEmitter_1 = __importDefault(require("./eventEmitter"));
const constants_1 = require("./constants");
class Context {
    constructor(params) {
        const { req, sendResponse, session, scenes, command, } = params;
        this.req = req;
        this.scenes = scenes;
        this.sendResponse = sendResponse;
        this.sessionId = req.session.session_id;
        this.messageId = req.session.message_id;
        this.userId = req.session.user_id;
        this.payload = req.request.payload;
        this.message = req.request.command;
        this.originalUtterance = req.request.original_utterance;
        this.session = session;
        this.eventEmitter = eventEmitter_1.default;
        this.replyBuilder = new replyBuilder_1.default(this.req);
        this.buttonBuilder = new buttonBuilder_1.default();
        this._isReplied = false;
        if (command) {
            this.command = command;
        }
    }
    get body() {
        const requestText = utils_1.selectCommand(this.req);
        if (typeof this.command.name === 'string') {
            return utils_1.reversedInterpolation(this.command.name, requestText);
        }
        return null;
    }
    reply(replyMessage) {
        if (typeof replyMessage === 'undefined') {
            throw new Error('Reply message could not be empty!');
        }
        const message = this._createReply(replyMessage);
        return this._sendReply(message);
    }
    enterScene(scene) {
        if (!scene) {
            throw new Error('Please provide scene you want to enter in');
        }
        const matchedScene = this.scenes.find(candidateScene => candidateScene.name === scene.name);
        this.session.setData('currentScene', matchedScene.name);
    }
    replyWithImage(params) {
        if (typeof params === 'string') {
            const message = this._createReply(reply_1.default({
                text: constants_1.EMPTY_SYMBOL,
                card: utils_1.compose(card_1.bigImageCard, card_1.image)(params),
            }));
            return this._sendReply(message);
        }
        const message = this._createReply(reply_1.default({
            text: constants_1.EMPTY_SYMBOL,
            card: card_1.bigImageCard(params),
        }));
        return this._sendReply(message);
    }
    replyWithItemsList(params) {
        const message = this._createReply(reply_1.default({
            text: constants_1.EMPTY_SYMBOL,
            card: card_1.itemsListCard(params),
        }));
        return this._sendReply(message);
    }
    leaveScene() {
        this.session.setData('currentScene', null);
    }
    goodbye(replyMessage) {
        if (typeof replyMessage === 'undefined') {
            throw new Error('Message should be string or result of ReplyBuilder.get');
        }
        const message = this._createReply(replyMessage);
        message.response.end_session = true;
        this._sendReply(message);
    }
    _createReply(replyMessage) {
        /**
         * Если @replyMessage — string,
         * то заворачиваем в стандартную форму.
         */
        if (typeof replyMessage === 'string') {
            replyMessage = this.replyBuilder
                .text(replyMessage)
                .tts(replyMessage)
                .get();
        }
        // Is no session, lets use context session
        if (!replyMessage.session) {
            replyMessage.session = this.session;
        }
        return replyMessage;
    }
    _sendReply(replyMessage) {
        if (this._isReplied) {
            return;
        }
        this._isReplied = true;
        /**
         * That fires when listening on port.
         */
        if (typeof this.sendResponse === 'function') {
            eventEmitter_1.default.dispatch(constants_1.EVENT_MESSAGE_SENT, {
                data: replyMessage.response.text,
                session: this.req.session,
            });
            return this.sendResponse(replyMessage);
        }
        return replyMessage;
    }
}
exports.default = Context;
