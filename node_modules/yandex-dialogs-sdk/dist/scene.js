"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const alice_1 = __importDefault(require("./alice"));
const commands_1 = __importDefault(require("./commands"));
class Scene extends alice_1.default {
    constructor(name, config = {}) {
        super();
        this.name = name;
        this.anyCallback = null;
        this.commands = new commands_1.default(config.fuseOptions || null);
        this.config = config;
        this.enterCommand = null;
        this.leaveCommand = null;
    }
    get title() {
        return this.name;
    }
    on(event) {
        /* enter, leave, etc */
    }
    /**
     * Trigger to activate the scene
     */
    enter(name, callback) {
        if (!name) {
            throw new Error('Enter command name is not specified');
        }
        this.enterCommand = new commands_1.default(this.config.fuseOptions || null);
        this.enterCommand.add(name, callback);
    }
    /**
     * Trigger to leave the scene
     */
    leave(name, callback) {
        if (!name) {
            throw new Error('Leave command name is not specified');
        }
        this.leaveCommand = new commands_1.default(this.config.fuseOptions || null);
        this.leaveCommand.add(name, callback);
    }
    command(name, callback) {
        this.commands.add(name, callback);
    }
    any(callback) {
        this.anyCallback = callback;
    }
    async isEnterCommand(ctx) {
        if (!this.enterCommand) {
            return false;
        }
        const matched = await this.enterCommand.search(ctx);
        return matched.length !== 0;
    }
    async isLeaveCommand(ctx) {
        if (!this.leaveCommand) {
            return false;
        }
        const matched = await this.leaveCommand.search(ctx);
        return matched.length !== 0;
    }
    async handleSceneRequest(req, sendResponse, ctx, type = null) {
        ctx.sendResponse = sendResponse;
        let requestedCommands = [];
        if (type === 'enter') {
            requestedCommands = [this.enterCommand.get()[0]];
        }
        else if (type === 'leave') {
            requestedCommands = [this.leaveCommand.get()[0]];
        }
        else {
            requestedCommands = await this.commands.search(ctx);
        }
        if (requestedCommands.length !== 0) {
            const requestedCommand = requestedCommands[0];
            return await requestedCommand.callback(ctx);
        }
        if (this.anyCallback) {
            return await this.anyCallback(ctx);
        }
        return Promise.resolve();
    }
}
exports.default = Scene;
