"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const formatToken = token => token
    .replace('$', '')
    .replace('{', '')
    .replace('}', '');
const MATCH_REGEX = /\${([a-z0-9]+)}/gi;
const SEARCH_REGEX_STR = '(.*)';
function extractTemplateTokenNames(template) {
    const matchedTokens = template.match(MATCH_REGEX).map(formatToken);
    const tokensObject = {};
    matchedTokens.forEach((token, index) => {
        tokensObject[token] = index;
    });
    return tokensObject;
}
function searchFiguresInString(template, stringFigure) {
    const searchTemplateRegex = getFiguresRegexp(template);
    const matched = searchTemplateRegex.exec(stringFigure);
    return matched.filter(Boolean).slice(1);
}
exports.searchFiguresInString = searchFiguresInString;
function getFiguresRegexp(figure) {
    const searchTemplate = figure.replace(MATCH_REGEX, SEARCH_REGEX_STR);
    return new RegExp(searchTemplate, 'ig');
}
exports.getFiguresRegexp = getFiguresRegexp;
function connectTokensWithFigures(tokens, figures) {
    const res = {};
    for (const token in tokens) {
        if (figures[tokens[token]]) {
            res[token] = figures[tokens[token]] || null;
        }
    }
    return res;
}
function reversedInterpolation(template, searchString) {
    if (!template) {
        throw new Error('No template provided');
    }
    if (!searchString) {
        throw new Error('No searchString provided');
    }
    const tokens = extractTemplateTokenNames(template);
    const figures = searchFiguresInString(template, searchString);
    return connectTokensWithFigures(tokens, figures);
}
exports.reversedInterpolation = reversedInterpolation;
exports.selectCommand = (req) => req.request.command;
exports.selectSession = req => req.session;
exports.selectSessionId = req => exports.selectSession(req).session_id;
exports.selectUserId = req => exports.selectSession(req).user_id;
exports.isFunction = (fn) => fn && typeof fn === 'function';
exports.delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
exports.rejectsIn = (ms) => new Promise((resolve, reject) => setTimeout(reject, ms));
exports.compose = (...fns) => fns.reduceRight((prevFn, nextFn) => (...args) => nextFn(prevFn(...args)), value => value);
exports.default = {
    getFiguresRegexp,
    selectCommand: exports.selectCommand,
    selectSession: exports.selectSession,
    selectSessionId: exports.selectSessionId,
    selectUserId: exports.selectUserId,
    isFunction: exports.isFunction,
    reversedInterpolation,
};
